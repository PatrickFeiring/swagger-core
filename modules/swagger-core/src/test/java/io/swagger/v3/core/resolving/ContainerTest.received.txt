package io.swagger.v3.core.resolving;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import io.swagger.v3.core.converter.AnnotatedType;
import io.swagger.v3.core.converter.ModelConverterContextImpl;
import io.swagger.v3.core.jackson.ModelResolver;
import io.swagger.v3.core.modern.ModernResolver;
import io.swagger.v3.core.resolving.resources.InnerType;
import io.swagger.v3.core.util.Json31;
import io.swagger.v3.core.util.Yaml31;
import io.swagger.v3.oas.models.media.ArraySchema;
import io.swagger.v3.oas.models.media.Schema;
import org.approvaltests.Approvals;
import org.approvaltests.core.Options;
import org.testng.annotations.Test;

import java.util.Map;

import static org.testng.Assert.assertEquals;
import static org.testng.Assert.assertNotNull;

public class ContainerTest extends SwaggerTestBase {

    static class ArrayBean {
        public int[] a;
    }

    @Test
    public void testIt() {
        final var model = new ModernResolver(mapper()).resolve(new AnnotatedType(ArrayBean.class), null, null);
        // language=yaml
        var expected = """
            properties:
              hey:
                type: string
            """;
        verifyInline(model, expected);
    }

    @Test
    public void testArray() throws Exception {
        final ModelResolver modelResolver = new ModelResolver(mapper());

        final ModelConverterContextImpl context = new ModelConverterContextImpl(modelResolver);

        final Schema model = context
                .resolve(new AnnotatedType(ArrayBean.class));

        final Map<String, Schema> props = model.getProperties();
        assertEquals(1, props.size());
        final Schema prop = props.get("a");
        assertNotNull(prop);
        assertEquals(prop.getType(), "array");

        final Schema items = ((ArraySchema) prop).getItems();
        assertNotNull(items);
        assertEquals(items.getType(), "integer");

        // language=yaml
        var expected = """
            properties:
              a:
                type: array
                items:
                  type: integer
                  format: int32
            """;
        verifyInline(model, expected);
    }

    public static void verifyInline(Schema model, String expected) {
        Approvals.verify(toJson31(model), new Options().inline(expected));
    }

    public static void verifyModel(Schema model) {
        Approvals.verify(toJson31(model), new Options().forFile().withExtension(".yaml"));
    }

    public static String toJson31(Object objectToSerialize) {
        return apply31(objectToSerialize, Json31.mapper());
    }

    private static String apply31(Object objectToSerialize, ObjectMapper mapper) {
        final ObjectNode lhs = mapper.convertValue(objectToSerialize, ObjectNode.class);
//        ObjectNode rhs = null;
//        try {
//            rhs = mapper.readValue(str, ObjectNode.class);
//        } catch (IOException e) {
//            LOGGER.error("Failed to read value", e);
//        }
        return Yaml31.pretty(lhs);
//        if (!lhs.equals(new SerializationMatchers.ObjectNodeComparator(), rhs)) {
//            assertEquals(Yaml31.pretty(lhs), Yaml31.pretty(rhs));
//        }
    }

    @Test
    public void testMap() throws Exception {
        final ModelResolver modelResolver = new ModelResolver(mapper());
        final ModelConverterContextImpl context = new ModelConverterContextImpl(modelResolver);

        final Schema model = context
                .resolve(new AnnotatedType(MapBean.class));

        final Map<String, Schema> props = model.getProperties();
        assertEquals(1, props.size());
        final Schema prop = props.get("stuff");
        assertNotNull(prop);
        assertEquals(prop.getType(), "object");

        final Schema items = (Schema)prop.getAdditionalProperties();
        assertNotNull(items);
        assertEquals(items.getType(), "string");
        assertEquals(items.getFormat(), "date-time");
        verifyModel(model);
    }

    @Test
    public void testComplexMap() throws Exception {
        ModelResolver resolver = new ModelResolver(mapper());

        final ModelConverterContextImpl context = new ModelConverterContextImpl(resolver);
        context.resolve(new AnnotatedType(WrapperType.class));

        final Map<String, Schema> models = context.getDefinedModels();
        final Schema innerType = models.get("InnerType");
        assertNotNull(innerType);
        final Map<String, Schema> innerProps = innerType.getProperties();
        assertEquals(innerProps.size(), 2);
        final Schema foo = innerProps.get("foo");
        assertEquals(foo.getType(), "integer");
        assertEquals(foo.getFormat(), "int32");
        final Schema name = innerProps.get("name");
        assertEquals(name.getType(), "string");

        final Schema wrapperType = models.get("WrapperType");
        assertNotNull(wrapperType);
        assertEquals(((Schema) wrapperType.getProperties().get("innerType")).getType(), "object");
        verifyModel(wrapperType);
    }

    static class MapBean {
        public Map<Short, java.util.Calendar> stuff;
    }

    static class WrapperType {
        public Map<Number, InnerType> innerType;
    }
}